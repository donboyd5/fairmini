---
output: html_document
editor_options:
  chunk_output_type: console
---

# Equation 1

{{< include _setup.qmd >}}

{{< include _load_data.qmd >}}

```{r}
#| label: eq1
#| output: false

# C constant
# C2 exog time varying constant term. 1, 2, 3, 4, 5, 6, 7, 8
# AA AG1, AG2, AG3 C, C2 CS POP RS YD

vars <- c("AA", "C", "C2", "CS", "POP", "RS", "YD")

eqd1 <- fmdata |> 
  filter(vname %in% vars) |> 
  bind_rows(fmages)

count(eqd1, vname) # AA, CS, POP, RS, YD
# need C, C2
# constant term is same up to 1969:4 (T1), then changes linearly up to some 1988:4 (T2) and unchanged through T

# C2 parameters
T1 <- "1969-10-01"
T2 <- "1988-10-01"


eqd2 <- eqd1 |> 
  select(-c(start, end)) |> 
  unnest(cols = data) |> 
  pivot_wider(names_from = vname) |> 
  arrange(date) |> 
  mutate(aa_pop = AA / POP,
         cs_pop = CS / POP,
         yda_pop = YD / POP,
         ln_cs_pop = log(cs_pop),
         ln_aa_pop_l1 = lag(log(aa_pop)),
         ln_cs_pop_l1 = lag(ln_cs_pop),
         ln_yda_pop = log(yda_pop),
         idx = row_number(),
         C = 1,
         C2 = case_when(
           date < T1 ~ 0,
           date < T2 ~ idx - idx[date == T1],
           date >= T2 ~ idx[date == T2] - idx[date == T1],
           .default = NA_real_)) |> 
  # get additional lagged values possibly needed for instrumental variables
  mutate(ln_cs_pop_l2  = lag(ln_cs_pop, 2),
         RS_l1         = lag(RS)) |> 
  na.omit() # drop any row that has an NA in any variable

eqd2 
summary(eqd2)

eqd3 <- eqd2 |> 
  filter(date >= "1954-01-01",
         date <= "2014-10-01")
summary(eqd3)

```

```{r}
#| label: ar1-function

ar1_correction <- function(data, formula, instruments, max_iter = 100, tol = 1e-5) {
  # -------------------------------------------------------------------------
  # data:       A data frame containing all variables (dependent var, regressors, instruments)
  # formula:    An R formula for the structural equation, e.g., y ~ x1 + x2
  # instruments: An R formula specifying instruments, e.g., ~ z1 + z2 + x3 (if x3 is exogenous)
  # max_iter:   Maximum number of AR(1) iterations
  # tol:        Convergence tolerance for the AR(1) coefficient (rho)
  #
  # Returns:    A list with:
  #              - model: final ivreg model object
  #              - rho:   estimated AR(1) coefficient
  #              - iterations: how many iterations were done
  # -------------------------------------------------------------------------
  
  # We'll need the 'AER' package for ivreg:
  if (!requireNamespace("AER", quietly = TRUE)) {
    stop("Package 'AER' needed for this function to work. Please install it.")
  }
  # For safety:
  library(AER)
  
  # 1) Combine 'formula' and 'instruments' into a single formula for ivreg
  #    ivreg requires something like:  y ~ x1 + x2 | z1 + z2 + ...
  #    If formula = y ~ x1 + x2 and instruments = ~ z1 + z2 + x3,
  #    then we build: y ~ x1 + x2 | z1 + z2 + x3
  
  iv_formula <- as.formula(
    paste(
      paste(deparse(formula), collapse = " "),
      paste(deparse(instruments), collapse = " ")
    )
  )
  
  # 2) Initial 2SLS fit ignoring serial correlation
  fit_iv <- ivreg(iv_formula, data = data)
  
  # Initialize old rho for iteration
  rho_old <- 0
  
  # 3) Iterative procedure
  for (i in seq_len(max_iter)) {
    # Extract residuals from the current IV fit
    resid_iv <- residuals(fit_iv)
    
    # Estimate AR(1) coefficient by regressing e_t on e_{t-1} (no intercept)
    # We'll skip the first residual, so index them carefully:
    fit_rho <- lm(resid_iv[-1] ~ 0 + resid_iv[-length(resid_iv)])
    rho_new <- coef(fit_rho)[1]
    
    # Check convergence in rho
    if (abs(rho_new - rho_old) < tol) {
      break
    }
    
    # 4) Cochrane–Orcutt transform all numeric columns (including instruments)
    data_t <- data
    numeric_cols <- sapply(data_t, is.numeric)
    
    # For each numeric column, transform y_t -> y_t - rho*y_{t-1}
    for (col_name in names(data_t)[numeric_cols]) {
      # Shift forward by 1 and subtract
      data_t[[col_name]][-1] <- data_t[[col_name]][-1] - rho_new * data_t[[col_name]][-(nrow(data_t))]
      # The first row is not transformable in standard CO; we'll drop it
    }
    
    # Remove the first observation (standard Cochrane–Orcutt)
    data_t <- data_t[-1, ]
    
    # 5) Re-fit 2SLS on the transformed data
    fit_iv_new <- ivreg(iv_formula, data = data_t)
    
    # Update the objects for the next iteration
    fit_iv <- fit_iv_new
    rho_old <- rho_new
  }
  
  # Return final model, final rho, and iteration count
  list(
    model = fit_iv,
    rho = rho_old,
    iterations = i
  )
}


```

## Equation 1 – log of real per-capita consumption of services

```{r}
#| label: eq1-estimation
#| output: true


# Step 4: Apply AR(1) correction
results <- ar1_correction(
  data = eqd3,
  formula = ln_cs_pop ~ C2 + AG1 + AG2 + AG3 + ln_cs_pop_l1 + ln_yda_pop + RS + ln_aa_pop_l1,
  instruments = ~ C2 + AG1 + AG2 + AG3 + ln_cs_pop_l2 + ln_yda_pop + RS_l1 + ln_aa_pop_l1,
  max_iter = 1000
)

# Step 5: Summarize the results
results$fit <- results$model
summary(results$fit)


# Step 6: Diagnostic checks
# Plot residuals over time
plot(residuals(results$fit), type = "l", main = "Residuals Over Time", xlab = "Time", ylab = "Residuals")

# ACF of residuals
acf(residuals(results$fit), main = "ACF of Residuals")

# Estimated AR(1) coefficient (rho)
cat("Estimated AR(1) coefficient (rho):", results$rho, "\n")

# calc rho for comparison
res <- residuals(results$fit)
rho_calc <- cor(res[-length(res)], res[-1])  # Correlation between residuals and their lag
rho_calc
# 0.08437705

```

```{r stop_here, echo=FALSE}
knitr::knit_exit()
```

```{r}
#| label: by-hand


# estimation period
# 1954.1 2014.4

eqd3 <- eqd2 |> 
  filter(date >= "1954-01-01",
         date <= "2014-10-01")
summary(eqd3)

# structural equation 
equation_1_form <- ln_cs_pop ~ C + C2 + AG1 + AG2 + AG3 +
                              ln_cs_pop_l1 + ln_yda_pop + RS + ln_aa_pop_l1

# define the instruments; typically for 2SLS we also use all exogenous variables plus suitable lags
instruments_1   <- ~ C + C2 + AG1 + AG2 + AG3 +
                    ln_cs_pop_l1 + ln_cs_pop_l2 + ln_yda_pop + RS_l1 + ln_aa_pop_l1

fit_plain <- ivreg(formula      = equation_1_form,
                   instruments  = instruments_1,
                   data         = eqd3)
summary(fit_plain)

res_plain <- residuals(fit_plain)

# 2) Estimate AR(1) parameter  (rho) from plain 2SLS residuals ----

eqd3a <- eqd3 |> 
  mutate(
    u_plain    = res_plain,
    u_plain_l1 = lag(u_plain)
    ) |> 
  na.omit() # drop first row that lacks the lag


do_ar1_iteration <- function(rho_old, data_in) {
  
  data_out <- data_in  |> 
    mutate(
      # Left-hand side, starred
      ln_cs_pop_star    = ln_cs_pop - rho_old * lag(ln_cs_pop),
      
      # Regressors, starred
      C_star            = C - rho_old * lag(C),
      C2_star           = C2 - rho_old * lag(C2),
      AG1_star          = AG1 - rho_old * lag(AG1),
      AG2_star          = AG2 - rho_old * lag(AG2),
      AG3_star          = AG3 - rho_old * lag(AG3),
      ln_cs_pop_l1_star = ln_cs_pop_l1 - rho_old * lag(ln_cs_pop_l1),
      ln_yda_pop_star   = ln_yda_pop - rho_old * lag(ln_yda_pop),
      RS_star           = RS - rho_old*lag(RS),
      ln_aa_pop_l1_star = ln_aa_pop_l1 - rho_old * lag(ln_aa_pop_l1),
      
      # Star the instruments as well:
      ln_cs_pop_l2_star = ln_cs_pop_l2 - rho_old * lag(ln_cs_pop_l2),
      RS_l1_star        = RS_l1 - rho_old * lag(RS_l1),
      
      # transform the old residual for re-estimating rho
      u_plain_star      = u_plain - rho_old * lag(u_plain)
    )
  
  data_out <- na.omit(data_out)
  # Now do 2SLS on starred eqn
  eqn_star <- ln_cs_pop_star ~ C_star + C2_star + AG1_star + AG2_star + AG3_star +
                               ln_cs_pop_l1_star + ln_yda_pop_star + RS_star + ln_aa_pop_l1_star
  
  inst_star <- ~ C_star + C2_star + AG1_star + AG2_star + AG3_star +
                 ln_cs_pop_l1_star + ln_cs_pop_l2_star + ln_yda_pop_star + RS_l1_star + ln_aa_pop_l1_star
  
  fit_star <- ivreg(eqn_star, inst_star, data=data_out)
  
  # residuals from that starred regression
  res_star <- residuals(fit_star)
  data_out$u_star <- res_star  
  
  # OLS of u_star on lag(u_star) to get new rho
  data_out <- data_out %>% mutate(u_star_l1 = lag(u_star,1)) %>% na.omit()
  rho_new <- coef(lm(u_star ~ u_star_l1, data=data_out))[2]
  
  list(fit=fit_star, data=data_out, rho=rho_new)
}

max_iter    <- 1000
tol         <- 1e-5
rho_current <- coef(lm(u_plain ~ u_plain_l1, data=eqd3a))[2]   # initial guess
rho_current
cat("Initial guess for rho =", rho_current,"\n")

final_out <- NULL
for (k in 1:max_iter) {
  out_k <- do_ar1_iteration(rho_current, eqd3a)
  rho_new <- out_k$rho
  cat(sprintf("Iteration %d: old rho=%.5f, new rho=%.5f\n",k, rho_current, rho_new))
  if (abs(rho_new - rho_current)<tol) {
    cat("Converged.\n")
    final_out <- out_k
    break
  }
  rho_current <- rho_new
  final_out   <- out_k
}

final_fit <- final_out$fit
cat("Final AR(1) coefficient (rho) =", final_out$rho,"\n")
summary(final_fit)
summary(eqd3a)
glimpse(eqd3a)

# final_fit is your "starred" regression. The reported coefficient
# estimates correspond to the structural eqn(1) parameters.
# Done!
# 



```

```{r}
#| label: system-fit



# system fit approach ----
# estimation period
# 1954.1 2014.4

# eqn1 <- log(CS/POP) ~ C + C2 + AG1 + AG2 + AG3 +
#                       lag(log(CS/POP),1) + log(YD/POP) +
#                       RS + lag(log(AA/POP),1)

eqn1 <- log(CS/POP) ~ C + C2 + AG1 + AG2 + AG3 +
                      lag(log(CS/POP),1) + log(YD/POP) +
                      RS + lag(log(AA/POP),1)

instr1 <- ~ C + C2 + AG1 + AG2 + AG3 +
          lag(log(CS/POP),1) + lag(log(CS/POP),2) +
          lag(log(YD/POP),1) + lag(RS,1) + lag(log(AA/POP),1)

eqn1 <- log(CS/POP) ~ C2 + AG1 + AG2 + AG3 +
                      lag(log(CS/POP),1) + log(YD/POP) +
                      RS + lag(log(AA/POP),1)

instr1 <- ~ C2 + AG1 + AG2 + AG3 +
          lag(log(CS/POP),1) + lag(log(CS/POP),2) +
          lag(log(YD/POP),1) + lag(RS,1) + lag(log(AA/POP),1)



eqns  <- list(eqn1 = eqn1)   # even though just one equation, we must pass a list
insts <- list(eqn1 = instr1)

fit   <- systemfit(eqns,
                   method="2SLS",
                   inst=insts,
                   data=eqd2 |> 
                     filter(date >= "1954-01-01",
                            date <= "2014-10-01"))
summary(fit)

# fit_ar1 <- systemfit(eqns,
#                      method="2SLS",
#                      inst=insts,
#                      data=eqd2 |> 
#                      filter(date >= "1954-01-01",
#                             date <= "2014-10-01"),
#                      rho=rep(0,1),    # initial guess for the AR(1) coefficient
#                      maxit=20,       # max number of iterations
#                      methodResidCov="AR1")
# summary(fit_ar1)




# 

```

## Recommended approach soup to nuts

```{r}
#| label: setup2

# Load necessary libraries
library(here)
library(tidyverse)
library(fs)
library(zoo)
library(btools)
 
library(lfe)         # For felm() function
library(lmtest)      # For robust standard errors
library(sandwich)    # For robust standard errors

source(here::here("R", "functions_eviews.R"))

dfair <- r"(E:\R_projects\projects\fairmini\data_raw\FMFP)"

```

```{r}
#| label: get-data2

fn <- "fmage.txt"; fpath <- fs::path(dfair, fn)
fmages <- get_eviews(fpath)
fmages |> 
  unnest(cols = data)

fn <- "fmdata.txt"; fpath <- fs::path(dfair, fn)
fmdata <- get_eviews(fpath)

```

```{r}
#| label: recommended

# Step 1: Prepare the data
# Assuming your data is in a data frame called `fmdata`
# and contains variables: AA, C, C2, CS, POP, RS, YD, AG1, AG2, AG3

# C constant
# C2 exog time varying constant term. 1, 2, 3, 4, 5, 6, 7, 8
# AA AG1, AG2, AG3 C, C2 CS POP RS YD

eqd1 <- fmdata |> 
  filter(vname %in% vars) |> 
  bind_rows(fmages)
count(eqd1, vname) # AA, CS, POP, RS, YD
# need C, C2
# constant term is same up to 1969:4 (T1), then changes linearly up to some 1988:4 (T2) and unchanged through T

eqd2 <- eqd1 |> 
  select(-c(start, end)) |> 
  unnest(cols = data) |> 
  pivot_wider(names_from = vname) |> 
  arrange(date) 

# C2 parameters
T1 <- "1969-10-01"
T2 <- "1988-10-01"

# Create necessary variables
eqd3 <- eqd2 |>
  mutate(
    # Per-capita variables
    aa_pop = AA / POP,
    cs_pop = CS / POP,
    yda_pop = YD / POP,
    
    # Log transformations
    ln_cs_pop = log(cs_pop),
    ln_aa_pop_l1 = lag(log(aa_pop)),
    ln_cs_pop_l1 = lag(ln_cs_pop),
    ln_yda_pop = log(yda_pop),
    
    # Time-varying constant term (C2)
    idx = row_number(),
    C = 1,
    C2 = case_when(
      date < as.Date("1969-10-01") ~ 0,
      date < as.Date("1988-10-01") ~ idx - idx[date == as.Date("1969-10-01")],
      date >= as.Date("1988-10-01") ~ idx[date == as.Date("1988-10-01")] - idx[date == as.Date("1969-10-01")],
      .default = NA_real_
    ),
    
    # Additional lags for instruments
    ln_cs_pop_l2 = lag(ln_cs_pop, 2),
    RS_l1 = lag(RS)
  ) |>
  na.omit()  # Drop rows with missing values
glimpse(eqd3)


# Filter data for the estimation period (1954:1–2014:4)
eqd4 <- eqd3 |>
  filter(date >= as.Date("1954-01-01"),
         date <= as.Date("2014-10-01"))

# Step 2: Estimate the model using felm()
# Structural equation: ln_cs_pop ~ C + C2 + AG1 + AG2 + AG3 + ln_cs_pop_l1 + ln_yda_pop + RS + ln_aa_pop_l1
# Instruments: C + C2 + AG1 + AG2 + AG3 + ln_cs_pop_l1 + ln_cs_pop_l2 + ln_yda_pop + RS_l1 + ln_aa_pop_l1
# AR(1) correction: Specify the time variable (date) for AR(1) structure

glimpse(eqd4)

fit_felm <- felm(
  ln_cs_pop ~ C2 + AG1 + AG2 + AG3 + ln_yda_pop + RS + ln_aa_pop_l1 |  # Exogenous vars
    0 |  # No fixed effects
    (ln_cs_pop_l1 ~ ln_cs_pop_l2 + RS_l1) |  # Endogenous var and instruments
    date,  # AR(1) correction
  data = eqd4
)


# Step 3: Summarize the results
summary(fit_felm)
plot(residuals(fit_felm), type = "l", main = "Residuals Over Time", xlab = "Time", ylab = "Residuals")
acf(residuals(fit_felm), main = "ACF of Residuals")

# Estimate AR(1) coefficient (rho) from residuals
res <- residuals(fit_felm)
rho <- cor(res[-length(res)], res[-1])  # Correlation between residuals and their lag
rho # .1506

# repeat, no AR correction
fit_felm_noar <- felm(
  ln_cs_pop ~ C2 + AG1 + AG2 + AG3 + ln_yda_pop + RS + ln_aa_pop_l1 |  # Exogenous vars
    0 |  # No fixed effects
    (ln_cs_pop_l1 ~ ln_cs_pop_l2 + RS_l1),
  data = eqd4)
summary(fit_felm_noar)
plot(residuals(fit_felm_noar), type = "l", main = "Residuals Over Time -- no AR(1)", xlab = "Time", ylab = "Residuals")
acf(residuals(fit_felm_noar), main = "ACF of Residuals -- no AR(1)") # lag 5
res <- residuals(fit_felm_noar)
rho <- cor(res[-length(res)], res[-1])  # Correlation between residuals and their lag
rho # .1506


# Step 4: Robust standard errors
# Compute robust standard errors using the sandwich package
coeftest(fit_felm, vcov = vcovHC(fit_felm, type = "HC1"))

# Step 5: Diagnostic checks
# Check for remaining serial correlation in residuals
acf(residuals(fit_felm), main = "ACF of Residuals")

# Plot residuals over time
plot(residuals(fit_felm), type = "l", main = "Residuals Over Time", xlab = "Time", ylab = "Residuals")


```

```{r}

eqd1 <- fmdata |> 
  filter(vname %in% vars) |> 
  bind_rows(fmages)
count(eqd1, vname) # AA, CS, POP, RS, YD
# need C, C2
# constant term is same up to 1969:4 (T1), then changes linearly up to some 1988:4 (T2) and unchanged through T

eqd2 <- eqd1 |> 
  select(-c(start, end)) |> 
  unnest(cols = data) |> 
  pivot_wider(names_from = vname) |> 
  arrange(date) 

# C2 parameters
T1 <- "1969-10-01"
T2 <- "1988-10-01"

# Create necessary variables
eqd3 <- eqd2 |>
  mutate(
    # Per-capita variables
    aa_pop = AA / POP,
    cs_pop = CS / POP,
    yda_pop = YD / POP,
    
    # Log transformations
    ln_cs_pop = log(cs_pop),
    ln_aa_pop_l1 = lag(log(aa_pop)),
    ln_cs_pop_l1 = lag(ln_cs_pop),
    ln_yda_pop = log(yda_pop),
    
    # Time-varying constant term (C2)
    idx = row_number(),
    C = 1,
    C2 = case_when(
      date < as.Date("1969-10-01") ~ 0,
      date < as.Date("1988-10-01") ~ idx - idx[date == as.Date("1969-10-01")],
      date >= as.Date("1988-10-01") ~ idx[date == as.Date("1988-10-01")] - idx[date == as.Date("1969-10-01")],
      .default = NA_real_
    ),
    
    # Additional lags for instruments
    ln_cs_pop_l2 = lag(ln_cs_pop, 2),
    RS_l1 = lag(RS)
  ) |>
  na.omit()  # Drop rows with missing values
glimpse(eqd3)

# Filter data for the estimation period (1954:1–2014:4)
eqd4 <- eqd3 |>
  filter(date >= as.Date("1954-01-01"),
         date <= as.Date("2014-10-01"))

# Step 2: Define the structural equation and instruments
# Structural equation: ln_cs_pop ~ C2 + AG1 + AG2 + AG3 + ln_cs_pop_l1 + ln_yda_pop + RS + ln_aa_pop_l1
# Instruments: C2 + AG1 + AG2 + AG3 + ln_cs_pop_l2 + ln_yda_pop + RS_l1 + ln_aa_pop_l1

# Step 3: Iterative AR(1) correction
# Function to perform AR(1) correction
ar1_correction <- function(data, formula, instruments, max_iter = 100, tol = 1e-5) {
  # Initial 2SLS estimation
  fit <- ivreg(formula, instruments, data = data)
  res <- residuals(fit)
  
  # Estimate AR(1) coefficient (rho)
  rho <- cor(res[-length(res)], res[-1])
  
  # Iterative process
  for (iter in 1:max_iter) {
    # Transform the data to remove AR(1) serial correlation
    data_transformed <- data |>
      mutate(
        ln_cs_pop_star = ln_cs_pop - rho * lag(ln_cs_pop),
        C2_star = C2 - rho * lag(C2),
        AG1_star = AG1 - rho * lag(AG1),
        AG2_star = AG2 - rho * lag(AG2),
        AG3_star = AG3 - rho * lag(AG3),
        ln_cs_pop_l1_star = ln_cs_pop_l1 - rho * lag(ln_cs_pop_l1),
        ln_yda_pop_star = ln_yda_pop - rho * lag(ln_yda_pop),
        RS_star = RS - rho * lag(RS),
        ln_aa_pop_l1_star = ln_aa_pop_l1 - rho * lag(ln_aa_pop_l1),
        ln_cs_pop_l2_star = ln_cs_pop_l2 - rho * lag(ln_cs_pop_l2),
        RS_l1_star = RS_l1 - rho * lag(RS_l1)
      ) |>
      na.omit()
    
    # Re-estimate the model with transformed data
    fit_transformed <- ivreg(
      ln_cs_pop_star ~ C2_star + AG1_star + AG2_star + AG3_star +
        ln_cs_pop_l1_star + ln_yda_pop_star + RS_star + ln_aa_pop_l1_star |
        C2_star + AG1_star + AG2_star + AG3_star + ln_cs_pop_l1_star + ln_cs_pop_l2_star +
        ln_yda_pop_star + RS_l1_star + ln_aa_pop_l1_star,
      data = data_transformed
    )
    
    # Update residuals and rho
    res_transformed <- residuals(fit_transformed)
    rho_new <- cor(res_transformed[-length(res_transformed)], res_transformed[-1])
    
    # Check for convergence
    if (abs(rho_new - rho) < tol) {
      cat("Converged at iteration", iter, "with rho =", rho_new, "\n")
      return(list(fit = fit_transformed, rho = rho_new, data = data_transformed))
    }
    
    rho <- rho_new
  }
  
  cat("Did not converge after", max_iter, "iterations. Final rho =", rho, "\n")
  return(list(fit = fit_transformed, rho = rho, data = data_transformed))
}

ar1_correction <- function(data, formula, instruments, max_iter = 100, tol = 1e-5) {
  # Initial 2SLS estimation
  fit <- ivreg(formula, instruments, data = data)
  res <- residuals(fit)
  
  # Estimate AR(1) coefficient (rho)
  rho <- cor(res[-length(res)], res[-1])
  
  # Iterative process
  for (iter in 1:max_iter) {
    # Transform the data to remove AR(1) serial correlation
    data_transformed <- data |>
      mutate(
        ln_cs_pop_star = ln_cs_pop - rho * lag(ln_cs_pop),
        C2_star = C2 - rho * lag(C2),
        AG1_star = AG1 - rho * lag(AG1),
        AG2_star = AG2 - rho * lag(AG2),
        AG3_star = AG3 - rho * lag(AG3),
        ln_cs_pop_l1_star = ln_cs_pop_l1 - rho * lag(ln_cs_pop_l1),
        ln_yda_pop_star = ln_yda_pop - rho * lag(ln_yda_pop),
        RS_star = RS - rho * lag(RS),
        ln_aa_pop_l1_star = ln_aa_pop_l1 - rho * lag(ln_aa_pop_l1),
        ln_cs_pop_l2_star = ln_cs_pop_l2 - rho * lag(ln_cs_pop_l2),
        RS_l1_star = RS_l1 - rho * lag(RS_l1)
      ) |>
      na.omit()
    
    # Re-estimate the model with transformed data
    fit_transformed <- ivreg(
      ln_cs_pop_star ~ C2_star + AG1_star + AG2_star + AG3_star +
        ln_cs_pop_l1_star + ln_yda_pop_star + RS_star + ln_aa_pop_l1_star |
        C2_star + AG1_star + AG2_star + AG3_star + ln_cs_pop_l1_star + ln_cs_pop_l2_star +
        ln_yda_pop_star + RS_l1_star + ln_aa_pop_l1_star,
      data = data_transformed
    )
    
    # Update residuals and rho
    res_transformed <- residuals(fit_transformed)
    rho_new <- cor(res_transformed[-length(res_transformed)], res_transformed[-1])
    
    # Check for convergence
    if (abs(rho_new - rho) < tol) {
      cat("Converged at iteration", iter, "with rho =", rho_new, "\n")
      return(list(fit = fit_transformed, rho = rho_new, data = data_transformed))
    }
    
    rho <- rho_new
  }
  
  cat("Did not converge after", max_iter, "iterations. Final rho =", rho, "\n")
  return(list(fit = fit_transformed, rho = rho, data = data_transformed))
}



ar1_correction <- function(data, formula, instruments, max_iter = 100, tol = 1e-5) {
  # Initial 2SLS estimation
  fit <- ivreg(formula, instruments, data = data)
  res <- residuals(fit)
  
  # Estimate AR(1) coefficient (rho)
  rho <- cor(res[-length(res)], res[-1])
  
  # Initialize transformed data
  data_transformed <- data
  
  # Iterative process
  for (iter in 1:max_iter) {
    # Transform the data to remove AR(1) serial correlation
    data_transformed <- data_transformed |>
      mutate(
        ln_cs_pop_star = ln_cs_pop - rho * lag(ln_cs_pop),
        C2_star = C2 - rho * lag(C2),
        AG1_star = AG1 - rho * lag(AG1),
        AG2_star = AG2 - rho * lag(AG2),
        AG3_star = AG3 - rho * lag(AG3),
        ln_cs_pop_l1_star = ln_cs_pop_l1 - rho * lag(ln_cs_pop_l1),
        ln_yda_pop_star = ln_yda_pop - rho * lag(ln_yda_pop),
        RS_star = RS - rho * lag(RS),
        ln_aa_pop_l1_star = ln_aa_pop_l1 - rho * lag(ln_aa_pop_l1),
        ln_cs_pop_l2_star = ln_cs_pop_l2 - rho * lag(ln_cs_pop_l2),
        RS_l1_star = RS_l1 - rho * lag(RS_l1)
      ) |>
      na.omit()
    
    # Update the unstarred variables with the starred variables
    data_transformed <- data_transformed |>
      mutate(
        ln_cs_pop = ln_cs_pop_star,
        C2 = C2_star,
        AG1 = AG1_star,
        AG2 = AG2_star,
        AG3 = AG3_star,
        ln_cs_pop_l1 = ln_cs_pop_l1_star,
        ln_yda_pop = ln_yda_pop_star,
        RS = RS_star,
        ln_aa_pop_l1 = ln_aa_pop_l1_star,
        ln_cs_pop_l2 = ln_cs_pop_l2_star,
        RS_l1 = RS_l1_star
      )
    
    # Re-estimate the model with transformed data
    fit_transformed <- ivreg(
      ln_cs_pop ~ C2 + AG1 + AG2 + AG3 +
        ln_cs_pop_l1 + ln_yda_pop + RS + ln_aa_pop_l1 |
        C2 + AG1 + AG2 + AG3 + ln_cs_pop_l1 + ln_cs_pop_l2 +
        ln_yda_pop + RS_l1 + ln_aa_pop_l1,
      data = data_transformed
    )
    
    # Update residuals and rho
    res_transformed <- residuals(fit_transformed)
    rho_new <- cor(res_transformed[-length(res_transformed)], res_transformed[-1])
    
    # Check for convergence
    if (abs(rho_new - rho) < tol) {
      cat("Converged at iteration", iter, "with rho =", rho_new, "\n")
      return(list(fit = fit_transformed, rho = rho_new, data = data_transformed))
    }
    
    rho <- rho_new
  }
  
  cat("Did not converge after", max_iter, "iterations. Final rho =", rho, "\n")
  return(list(fit = fit_transformed, rho = rho, data = data_transformed))
}



ar1_correction <- function(data, formula, instruments, max_iter = 100, tol = 1e-5) {
  # -------------------------------------------------------------------------
  # data:       A data frame containing all variables (dependent var, regressors, instruments)
  # formula:    An R formula for the structural equation, e.g., y ~ x1 + x2
  # instruments: An R formula specifying instruments, e.g., ~ z1 + z2 + x3 (if x3 is exogenous)
  # max_iter:   Maximum number of AR(1) iterations
  # tol:        Convergence tolerance for the AR(1) coefficient (rho)
  #
  # Returns:    A list with:
  #              - model: final ivreg model object
  #              - rho:   estimated AR(1) coefficient
  #              - iterations: how many iterations were done
  # -------------------------------------------------------------------------
  
  # We'll need the 'AER' package for ivreg:
  if (!requireNamespace("AER", quietly = TRUE)) {
    stop("Package 'AER' needed for this function to work. Please install it.")
  }
  # For safety:
  library(AER)
  
  # 1) Combine 'formula' and 'instruments' into a single formula for ivreg
  #    ivreg requires something like:  y ~ x1 + x2 | z1 + z2 + ...
  #    If formula = y ~ x1 + x2 and instruments = ~ z1 + z2 + x3,
  #    then we build: y ~ x1 + x2 | z1 + z2 + x3
  
  iv_formula <- as.formula(
    paste(
      paste(deparse(formula), collapse = " "),
      paste(deparse(instruments), collapse = " ")
    )
  )
  
  # 2) Initial 2SLS fit ignoring serial correlation
  fit_iv <- ivreg(iv_formula, data = data)
  
  # Initialize old rho for iteration
  rho_old <- 0
  
  # 3) Iterative procedure
  for (i in seq_len(max_iter)) {
    # Extract residuals from the current IV fit
    resid_iv <- residuals(fit_iv)
    
    # Estimate AR(1) coefficient by regressing e_t on e_{t-1} (no intercept)
    # We'll skip the first residual, so index them carefully:
    fit_rho <- lm(resid_iv[-1] ~ 0 + resid_iv[-length(resid_iv)])
    rho_new <- coef(fit_rho)[1]
    
    # Check convergence in rho
    if (abs(rho_new - rho_old) < tol) {
      break
    }
    
    # 4) Cochrane–Orcutt transform all numeric columns (including instruments)
    data_t <- data
    numeric_cols <- sapply(data_t, is.numeric)
    
    # For each numeric column, transform y_t -> y_t - rho*y_{t-1}
    for (col_name in names(data_t)[numeric_cols]) {
      # Shift forward by 1 and subtract
      data_t[[col_name]][-1] <- data_t[[col_name]][-1] - rho_new * data_t[[col_name]][-(nrow(data_t))]
      # The first row is not transformable in standard CO; we'll drop it
    }
    
    # Remove the first observation (standard Cochrane–Orcutt)
    data_t <- data_t[-1, ]
    
    # 5) Re-fit 2SLS on the transformed data
    fit_iv_new <- ivreg(iv_formula, data = data_t)
    
    # Update the objects for the next iteration
    fit_iv <- fit_iv_new
    rho_old <- rho_new
  }
  
  # Return final model, final rho, and iteration count
  list(
    model = fit_iv,
    rho = rho_old,
    iterations = i
  )
}


# Step 4: Apply AR(1) correction
results <- ar1_correction(
  data = eqd4,
  formula = ln_cs_pop ~ C2 + AG1 + AG2 + AG3 + ln_cs_pop_l1 + ln_yda_pop + RS + ln_aa_pop_l1,
  instruments = ~ C2 + AG1 + AG2 + AG3 + ln_cs_pop_l2 + ln_yda_pop + RS_l1 + ln_aa_pop_l1,
  max_iter = 1000
)

# Step 5: Summarize the results
results$fit <- results$model
summary(results$fit)

# Step 6: Diagnostic checks
# Plot residuals over time
plot(residuals(results$fit), type = "l", main = "Residuals Over Time", xlab = "Time", ylab = "Residuals")

# ACF of residuals
acf(residuals(results$fit), main = "ACF of Residuals")

# Estimated AR(1) coefficient (rho)
cat("Estimated AR(1) coefficient (rho):", results$rho, "\n")

# calc rho for comparison
res <- residuals(results$fit)
rho_calc <- cor(res[-length(res)], res[-1])  # Correlation between residuals and their lag
rho_calc
# 0.08437705

```

## Variables

AA

AG1, AG2, AG3

C, C2

CS

POP

RS

YD

![](images/clipboard-505718086.png)
